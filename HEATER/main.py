import datetime

# Set the name of your input data here
f_Input = open("./TEMP85.txt", "r")

class DataPoint():
    def __init__(self, s_InputLine):
        # Sample line:
        #   [0 00:00:12.0172] {"temp":31.35028,"freq":610.0425,"ADC":[-0.141923,2994.008,2994.718,0,2951.573,-0.141923]}
        
        # Split at spaces:
        # "[0", "00:00:12.0172]", "{"temp":31.35028,"freq":610.0425,"ADC":[-0.141923,2994.008,2994.718,0,2951.573,-0.141923]}"
        a_Input = s_InputLine.split(" ")

        # Store the first value in a model variable:
        self.i_InputChannel = int(a_Input[0].replace("[",""))

        # Store the time stamp in another model variable:
        s_TimeInfo      = a_Input[1].replace("]","")
        a_TimeInfo      = s_TimeInfo.split(".")
        self.i_Milliseconds  = int(a_TimeInfo[1])
        a_TimeInfo      = a_TimeInfo[0].split(":")
        self.i_Seconds       = int(a_TimeInfo[2])
        self.i_Minutes       = int(a_TimeInfo[1])
        self.i_Hours         = int(a_TimeInfo[0])
        
        self.d_Time     = datetime.datetime(year = 2021,month= 1, day = 1) + datetime.timedelta(hours=self.i_Hours, minutes=self.i_Minutes, seconds=self.i_Seconds, microseconds=self.i_Milliseconds*1000)

        # Store the returned values
        
        s_DataValues     = a_Input[2].replace("{", "").replace("}", "")
        a_DataValues     = s_DataValues.split("ADC")
        s_TempFreq       = a_DataValues[0]
        a_TempFreq       = s_TempFreq.split(",")
        self.f_Temp             = float(a_TempFreq[0].split(":")[1])
        self.f_Freq             = float(a_TempFreq[1].split(":")[1])
        s_Adc              = a_DataValues[1].replace(":", "").replace("[", "").replace("]", "")
        self.a_Adc          = []
        a_Adc = s_Adc.split(",")
        for s_Val in a_Adc:
            s_Val = s_Val.replace('"',"")
            self.a_Adc.append(float(s_Val))

    def __str__(self):
        return f"Time: {self.d_Time}, Temperature: {self.f_Temp}, Frequency: {self.f_Freq}, ADC: {self.a_Adc}"

class DataManager():
    def __init__(self):

        self.a_Data = []
        self.a_CorruptedData = []
        self.a_HealedData = []
        
        for s_Line in f_Input.readlines():
            if len(s_Line) < 70:
                pass
            else:
                s_Line = s_Line.replace("\n", "")
                try: 
                    o_Data = DataPoint(s_Line)

                    self.a_Data.append(o_Data)
                except Exception as e:
                    self.a_CorruptedData.append(f"{type(e)}: {s_Line}")
                    self.AutoHeal(e, s_Line)

        self.i_NumDataPoints           =   len(self.a_Data)
        self.i_NumCorruptedDataPoints  =   len(self.a_CorruptedData)
        self.i_NumHealedDataPoints     =   len(self.a_HealedData)

        self.f_CorruptionRate       =   float(self.i_NumCorruptedDataPoints/self.i_NumDataPoints)
        self.f_HealingRate          =   float(self.i_NumHealedDataPoints/self.i_NumCorruptedDataPoints)
    
    def AutoHeal(self, o_Error, s_CorruptedLine):
        if type(o_Error) == ValueError:
            # Check if the word temp appears twice:
            b_isMissingUniqueTimeStamp = len(s_CorruptedLine.split("temp")) > 2
            if b_isMissingUniqueTimeStamp:
                self.FixBrokenTimeStamp(s_CorruptedLine)
        else:
            print(s_CorruptedLine)

    def FixBrokenTimeStamp(self, s_CorruptedLine):
        # First, break the two data points up by splitting at }{
        a_DataPoints = s_CorruptedLine.split("}{")

        # Create an object from the first data point
        o_DataPoint1    = DataPoint(a_DataPoints[0])

        # Predict when the next data point's time stamp should be based on the first
        s_AutogeneratedTimestamp = f"[0 {o_DataPoint1.i_Hours}:{o_DataPoint1.i_Minutes}:{o_DataPoint1.i_Seconds}.{o_DataPoint1.i_Milliseconds + 500}] "
        s_HealedDataPoint        = s_AutogeneratedTimestamp + a_DataPoints[1]

        try:
            o_DataPoint2    = DataPoint(s_HealedDataPoint)
            self.a_Data.append(o_DataPoint1)
            self.a_Data.append(o_DataPoint2)
            self.a_HealedData.append(o_DataPoint1)
            self.a_HealedData.append(o_DataPoint2)
        except Exception as e:
            print(e) 

    def CreateCSV(self):
        f_Output    = open("output1.csv", "w")
        for o_Data in self.a_Data:
            f_Output.write(f"{(o_Data.d_Time - datetime.datetime(2021,1,1)).total_seconds()}, {o_Data.f_Temp}, {o_Data.f_Freq}\n")

                

o_DataManager = DataManager()
for s_CorruptedData in o_DataManager.a_CorruptedData:
    pass #print(s_CorruptedData)
    
print(f"Corruption Rate: {100*o_DataManager.f_CorruptionRate}%")
print(f"Corruption Rate: {100*o_DataManager.f_HealingRate}%")

o_DataManager.CreateCSV()

# Issues:
#   - We need better markers between header data and test data
#   - We need to add a known splitter object in the test data since commas
#       are needed to distinguish ADC data
#   - Cannot really just split the line at ADC since the data breaks at some points